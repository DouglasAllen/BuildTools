using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;

namespace ApiCheck
{
    public class BaselineGenerator
    {
        private const BindingFlags SearchFlags = BindingFlags.Public |
            BindingFlags.NonPublic |
            BindingFlags.Instance |
            BindingFlags.Static |
            BindingFlags.DeclaredOnly;

        private readonly Assembly _assembly;

        public BaselineGenerator(Assembly assembly)
        {
            _assembly = assembly;
        }

        public static JObject GenerateBaselineReport(Assembly assembly)
        {
            var generator = new BaselineGenerator(assembly);
            var baselineDocument = generator.GenerateBaseline();
            return JObject.FromObject(baselineDocument);
        }

        public BaselineDocument GenerateBaseline()
        {
            var types = _assembly.DefinedTypes;

            var document = new BaselineDocument();
            document.AssemblyIdentity = _assembly.GetName().ToString();
            var baselineTypes = new Dictionary<TypeInfo, TypeBaseline>();

            foreach (var type in _assembly.DefinedTypes)
            {
                var baselineType = GenerateTypeBaseline(type, baselineTypes);
                document.Types.Add(baselineType);
            }

            return document;
        }

        private TypeBaseline GenerateTypeBaseline(TypeInfo type, IDictionary<TypeInfo, TypeBaseline> baselineTypes)
        {
            var typeBaseline = new TypeBaseline();

            typeBaseline.Name = TypeBaseline.GetTypeNameFor(type);

            typeBaseline.Kind = type.IsInterface ? BaselineKind.Interface : type.IsValueType ? BaselineKind.Struct : BaselineKind.Class;

            typeBaseline.Visibility = type.IsPublic || type.IsNestedPublic ? BaselineVisibility.Public :
                type.IsNestedFamORAssem ? BaselineVisibility.ProtectedInternal :
                type.IsNestedFamily ? BaselineVisibility.Protected :
                type.IsNestedPrivate ? BaselineVisibility.Private :
                BaselineVisibility.Internal;

            typeBaseline.Static = typeBaseline.Kind == BaselineKind.Class && type.IsSealed && type.IsAbstract;

            typeBaseline.Abstract = type.IsAbstract;

            typeBaseline.Sealed = type.IsSealed;

            if (type.BaseType != null && type.BaseType != typeof(object) && type.BaseType != typeof(ValueType))
            {
                typeBaseline.BaseType = TypeBaseline.GetTypeNameFor(type.BaseType.GetTypeInfo());
            }

            if (type.ImplementedInterfaces?.Count() > 0)
            {
                var interfaces = TypeBaseline.GetImplementedInterfacesFor(type);
                foreach (var @interface in interfaces.Select(i => TypeBaseline.GetTypeNameFor(i)))
                {
                    typeBaseline.ImplementedInterfaces.Add(@interface);
                }
            }

            var members = type.GetMembers(SearchFlags);

            foreach (var member in members)
            {
                var memberBaseline = GenerateMemberBaseline(type, member);
                if (memberBaseline != null)
                {
                    typeBaseline.Members.Add(memberBaseline);
                }
            }

            return typeBaseline;
        }

        private MemberBaseline GenerateMemberBaseline(TypeInfo type, MemberInfo member)
        {
            switch (member.MemberType)
            {
                case MemberTypes.Constructor:
                    var ctor = (ConstructorInfo)member;
                    var constructorBaseline = new MemberBaseline();
                    constructorBaseline.Kind = MemberBaselineKind.Constructor;
                    constructorBaseline.Visibility = ctor.IsPublic ? BaselineVisibility.Public :
                        ctor.IsFamilyOrAssembly ? BaselineVisibility.ProtectedInternal :
                        ctor.IsFamily ? BaselineVisibility.Protected :
                        ctor.IsPrivate ? BaselineVisibility.Private : BaselineVisibility.Internal;

                    constructorBaseline.Name = MemberBaseline.GetMemberNameFor(ctor);
                    foreach (var parameter in ctor.GetParameters())
                    {
                        var parameterBaseline = GenerateParameterBaseline(parameter);
                        constructorBaseline.Parameters.Add(parameterBaseline);
                    }

                    return constructorBaseline;
                case MemberTypes.Method:
                    var name = member.Name;
                    var method = (MethodInfo)member;
                    var methodBaseline = new MemberBaseline();

                    methodBaseline.Kind = MemberBaselineKind.Method;

                    methodBaseline.Visibility = method.IsPublic ? BaselineVisibility.Public :
                        method.IsFamilyOrAssembly ? BaselineVisibility.ProtectedInternal :
                        method.IsFamily ? BaselineVisibility.Protected :
                        method.IsPrivate ? BaselineVisibility.Private : BaselineVisibility.Internal;

                    methodBaseline.Name = MemberBaseline.GetMemberNameFor(method);

                    methodBaseline.Static = method.IsStatic;
                    methodBaseline.Sealed = method.IsFinal;
                    methodBaseline.Virtual = method.IsVirtual;
                    methodBaseline.Override = method.IsVirtual && method.GetBaseDefinition() != method;
                    methodBaseline.Abstract = method.IsAbstract;
                    methodBaseline.New = method.IsHideBySig;

                    foreach (var parameter in method.GetParameters())
                    {
                        var parameterBaseline = GenerateParameterBaseline(parameter);
                        methodBaseline.Parameters.Add(parameterBaseline);
                    }

                    methodBaseline.ReturnType = TypeBaseline.GetTypeNameFor(method.ReturnType.GetTypeInfo());

                    return methodBaseline;
                case MemberTypes.Field:
                    var field = (FieldInfo)member;
                    var fieldBaseline = new MemberBaseline();

                    fieldBaseline.Visibility = field.IsPublic ? BaselineVisibility.Public :
                        field.IsFamilyOrAssembly ? BaselineVisibility.ProtectedInternal :
                        field.IsFamily ? BaselineVisibility.Protected :
                        field.IsPrivate ? BaselineVisibility.Private : BaselineVisibility.Internal;

                    fieldBaseline.Static = field.IsStatic;
                    fieldBaseline.ReadOnly = field.IsInitOnly;
                    fieldBaseline.Kind = MemberBaselineKind.Field;

                    fieldBaseline.Name = field.Name;
                    fieldBaseline.ReturnType = TypeBaseline.GetTypeNameFor(field.FieldType.GetTypeInfo());

                    return fieldBaseline;
                case MemberTypes.Event:
                case MemberTypes.Property:
                case MemberTypes.NestedType:
                    // All these cases are covered by the methods they implicitly define on the class
                    // (Properties and Events) and when we enumerate all the types in an assembly (Nested types).
                    return null;
                case MemberTypes.TypeInfo:
                // There should not be any member passsed into this method that is not a top level type.
                case MemberTypes.Custom:
                // We don't know about custom member types, so better throw if we find something we don't understand.
                case MemberTypes.All:
                    throw new InvalidOperationException($"'{type.MemberType}' [{member}] is not supported.");
                default:
                    return null;
            }

            //                                case MemberTypes.Constructor:
            //                        var constructor = (ConstructorInfo)member;
            //            if (!(constructor.IsPublic || constructor.IsFamily))
            //            {
            //                break;
            //            }

            //            var ctorVisibility = constructor.IsPublic ? "public" : "protected";
            //            var ctorParameters = string.Join(", ", constructor.GetParameters().Select(pi => GetParameterId(pi)));
            //            var ctorId = $"{ctorVisibility} {GetTypeName(constructor.DeclaringType.GetTypeInfo())}({ctorParameters})";

            //            memberReport = new JObject { ["id"] = ctorId };
            //            break;
            //                    case MemberTypes.Method:
            //                        var method = (MethodInfo)member;
            //            if (!(method.IsPublic || method.IsFamily))
            //            {
            //                break;
            //            }

            //            var methodVisibility = method.IsPublic ? "public" : "protected";
            //            var methodParameters = string.Join(", ", method.GetParameters().Select(pi => GetParameterId(pi)));
            //            var returnType = GetTypeName(method.ReturnType.GetTypeInfo());
            //            var typeName = GetTypeName(method.DeclaringType.GetTypeInfo());
            //            var methodName = GetMethodName(method);
            //            var staticNess = method.IsStatic ? " static " : "";
            //            var @virtual = method.IsVirtual ? " virtual " : "";
            //            var methodId = $"{methodVisibility}{staticNess}{@virtual}{returnType} {typeName}.{methodName}({methodParameters})";

            //            memberReport = new JObject { ["id"] = methodId };

            //            break;
            //                    case MemberTypes.Field:
            //                        var field = (FieldInfo)member;
            //            break;
            //                    case MemberTypes.Event:
            //                    case MemberTypes.Property:
            //                    // Skip as these are covered by getters and setters on the
            //                    // property and the add remove methods on the class.
            //                    case MemberTypes.NestedType:
            //                        // Skip as is covered by iterating through all the exported types.
            //                        break;
            //                    case MemberTypes.TypeInfo:
            //                    case MemberTypes.Custom:
            //                    case MemberTypes.All:
            //                        throw new InvalidOperationException("Unknown member type");
            //            default:
            //                        break;
            //        }
            //                if (memberReport != null)
            //                {
            //                    result.Add(memberReport);
            //                }
            //}

            //            return result;
            //        }

            //        private JToken GetTypeId(TypeInfo type)
            //        {
            //            var visibility = type.IsPublic || type.IsNestedPublic ? "public " : (type.IsNestedFamily ? "protected " : "");
            //            var kind = type.IsInterface ? "interface " : "class ";

            //            var nature = type.IsAbstract && type.IsSealed ? "static " : (type.IsAbstract ? "abstract " : "");
            //            var baseClassSuffix = type.BaseType != null && type.BaseType != typeof(object) ? $"{GetTypeName(type.BaseType.GetTypeInfo())}" : "";

            //            var directInterfaceImplementations = type.ImplementedInterfaces
            //                .Except(type.ImplementedInterfaces.SelectMany(ii => ii.GetTypeInfo().ImplementedInterfaces));
            //            var implementedInterfacesSuffix = string.Join(", ", directInterfaceImplementations.Select(ii => GetTypeName(ii.GetTypeInfo())));

            //            var classSufix = implementedInterfacesSuffix != "" || baseClassSuffix != "" ?
            //                $" : {string.Join(", ", baseClassSuffix, implementedInterfacesSuffix)}" :
            //                "";

            //            return $"{visibility}{nature}{kind}{GetTypeName(type)}{classSufix}";
            //        }

            //        private static object GetMethodName(MethodInfo method)
            //        {
            //            if (!method.IsGenericMethod)
            //            {
            //                return method.Name;
            //            }

            //            var arguments = method.GetGenericArguments();
            //            return $"{method.Name}<{string.Join(", ", arguments.Select(a => GetTypeName(a.GetTypeInfo())))}>";
            //        }

            //        private static string GetParameterId(ParameterInfo parameter)
            //        {
            //            var defaultValue = parameter.HasDefaultValue ? $" = {parameter.RawDefaultValue}" : "";
            //            var @params = parameter.GetCustomAttribute<ParamArrayAttribute>() != null ? "params " : "";
            //            var modifier = parameter.ParameterType.IsByRef && parameter.IsOut ? "out " : (parameter.ParameterType.IsByRef && !parameter.IsOut ? "ref " : "");
            //            var parameterTypeName = GetTypeName(parameter.ParameterType.GetTypeInfo()).TrimEnd('&');
            //            return $"{@params}{modifier}{parameterTypeName} {parameter.Name}{defaultValue}";
            //        }

            //        private static string GetTypeName(TypeInfo type)
            //        {
            //            if (type.IsGenericParameter)
            //            {
            //                return type.Name;
            //            }

            //            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
            //            {
            //                return $"{GetTypeName(type.GetGenericArguments().Single().GetTypeInfo())}?";
            //            }

            //            if (type.IsGenericType)
            //            {
            //                var name = type.GetGenericTypeDefinition().FullName;
            //                name = name.Substring(0, name.IndexOf('`'));
            //                return $"{name}<{string.Join(", ", type.GenericTypeArguments.Select(ga => GetTypeName(ga.GetTypeInfo())))}>";
            //            }

            //            return type.FullName;
            //        }
        }

        private ParameterBaseline GenerateParameterBaseline(ParameterInfo parameter)
        {
            return new ParameterBaseline
            {
                Name = parameter.Name,
                Type = TypeBaseline.GetTypeNameFor(parameter.ParameterType.GetTypeInfo()),
                Direction = parameter.ParameterType.IsByRef && parameter.IsOut ? BaselineParameterDirection.Out :
                    parameter.ParameterType.IsByRef && !parameter.IsOut ? BaselineParameterDirection.Ref :
                    BaselineParameterDirection.In,
                DefaultValue = parameter.HasDefaultValue ? FormatDefaultValue(parameter) : null,
                IsParams = parameter.GetCustomAttribute<ParamArrayAttribute>() != null
            };
        }

        private static string FormatDefaultValue(ParameterInfo parameter)
        {
            if (parameter.RawDefaultValue == null)
            {
                var parameterTypeInfo = parameter.ParameterType.GetTypeInfo();
                if (parameterTypeInfo.IsValueType)
                {
                    return $"default({TypeBaseline.GetTypeNameFor(parameterTypeInfo)})";
                }

                return "null";
            }

            if (parameter.ParameterType == typeof(string))
            {
                return $"\"{parameter.RawDefaultValue}\"";
            }

            if (parameter.ParameterType == typeof(char))
            {
                return $"'{parameter.RawDefaultValue}'";
            }

            if (parameter.ParameterType == typeof(bool) ||
                parameter.ParameterType == typeof(byte) ||
                parameter.ParameterType == typeof(sbyte) ||
                parameter.ParameterType == typeof(short) ||
                parameter.ParameterType == typeof(ushort) ||
                parameter.ParameterType == typeof(int) ||
                parameter.ParameterType == typeof(uint) ||
                parameter.ParameterType == typeof(long) ||
                parameter.ParameterType == typeof(ulong) ||
                parameter.ParameterType == typeof(double) ||
                parameter.ParameterType == typeof(float) ||
                parameter.ParameterType == typeof(decimal))
            {
                return parameter.RawDefaultValue.ToString();
            }

            throw new InvalidOperationException("Unsupported default value type");
        }

        public class BaselineDocument
        {
            public string AssemblyIdentity { get; set; }
            public IList<TypeBaseline> Types { get; } = new List<TypeBaseline>();
        }

        public abstract class BaselineItem
        {
            public abstract string Id { get; }
        }

        [DebuggerDisplay("{Id,nq}")]
        public class TypeBaseline : BaselineItem
        {
            public override string Id
            {
                get
                {
                    return string.Join(" ", GetMembers());
                }
            }

            public string Name { get; set; }

            public BaselineVisibility Visibility { get; set; }

            public BaselineKind Kind { get; set; }

            public bool Abstract { get; set; }

            public bool Static { get; set; }

            public bool Sealed { get; set; }

            public string BaseType { get; set; }
            public IList<string> ImplementedInterfaces { get; } = new List<string>();
            public IList<MemberBaseline> Members { get; set; } = new List<MemberBaseline>();

            private IEnumerable<string> GetMembers()
            {
                switch (Visibility)
                {
                    case BaselineVisibility.Public:
                        yield return "public";
                        break;
                    case BaselineVisibility.Protected:
                        yield return "protected";
                        break;
                    case BaselineVisibility.Internal:
                        yield return "internal";
                        break;
                    case BaselineVisibility.ProtectedInternal:
                        yield return "protected";
                        yield return "internal";
                        break;
                    case BaselineVisibility.Private:
                        yield return "private";
                        break;
                    default:
                        break;
                }

                if (Static)
                {
                    yield return "static";
                }

                if (Abstract && Kind == BaselineKind.Class)
                {
                    yield return "abstract";
                }

                if (Sealed)
                {
                    yield return "sealed";
                }

                switch (Kind)
                {
                    case BaselineKind.Struct:
                        yield return "struct";
                        break;
                    case BaselineKind.Interface:
                        yield return "interface";
                        break;
                    case BaselineKind.Class:
                        yield return "class";
                        break;
                    default:
                        break;
                }

                yield return Name;

                if (BaseType != null || ImplementedInterfaces.Count > 0)
                {
                    yield return ":";
                    yield return string.Join(", ", GetBaseTypeAndImplementedInterfaces());
                }

            }

            private IEnumerable<string> GetBaseTypeAndImplementedInterfaces()
            {
                if (BaseType != null)
                {
                    yield return BaseType;
                }

                foreach (var @interface in ImplementedInterfaces)
                {
                    if (@interface != null)
                    {
                        yield return @interface;
                    }
                }
            }

            public static string GetTypeNameFor(TypeInfo type)
            {
                string typeName = type.FullName;

                if (type.IsGenericParameter)
                {
                    typeName = type.Name;
                }

                if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
                {
                    typeName = $"{GetTypeNameFor(type.GetGenericArguments().Single().GetTypeInfo())}?";
                }

                if (type.IsGenericType)
                {
                    var name = type.GetGenericTypeDefinition().FullName;
                    name = name.Substring(0, name.IndexOf('`'));
                    typeName = $"{name}<{string.Join(", ", type.GenericTypeArguments.Select(ga => GetTypeNameFor(ga.GetTypeInfo())))}>";
                }

                if (type.IsPointer)
                {
                    typeName = typeName.TrimEnd('&');
                }

                return typeName;
            }

            public static IEnumerable<TypeInfo> GetImplementedInterfacesFor(TypeInfo type)
            {
                if (!type.IsInterface)
                {
                    var interfaces = type.ImplementedInterfaces;
                    foreach (var implementedInterface in interfaces)
                    {
                        var mapping = type.GetRuntimeInterfaceMap(implementedInterface);
                        if (type.BaseType.GetTypeInfo().ImplementedInterfaces.Any(i => i.GetTypeInfo().Equals(implementedInterface)) &&
                            !mapping.TargetMethods.Any(t => t.DeclaringType.Equals(type)))
                        {
                            continue;
                        }

                        if (mapping.TargetType.Equals(type))
                        {
                            yield return implementedInterface.GetTypeInfo();
                        }
                    }
                }
                else
                {
                    var implementedInterfaces = type.ImplementedInterfaces.Select(i => i.GetTypeInfo());
                    var includedInterfaces = implementedInterfaces.SelectMany(i => i.ImplementedInterfaces.Select(ii => ii.GetTypeInfo()));
                    var directlyImplementedInterfaces = implementedInterfaces.Except(includedInterfaces);

                    foreach (var directInterface in directlyImplementedInterfaces)
                    {
                        yield return directInterface;
                    }
                }
            }
        }

        [JsonConverter(typeof(StringEnumConverter))]
        public enum BaselineKind
        {
            Struct,
            Interface,
            Class
        }

        [JsonConverter(typeof(StringEnumConverter))]
        public enum MemberBaselineKind
        {
            Constructor,
            Method,
            Field
        }

        [JsonConverter(typeof(StringEnumConverter))]
        public enum BaselineVisibility
        {
            Public,
            Protected,
            Internal,
            ProtectedInternal,
            Private
        }

        [DebuggerDisplay("{Id,nq}")]
        public class MemberBaseline : BaselineItem
        {
            public override string Id
            {
                get
                {
                    return string.Join(" ", GetComponents());
                }
            }

            private IEnumerable<string> GetComponents()
            {
                switch (Visibility)
                {
                    case BaselineVisibility.Public:
                        yield return "public";
                        break;
                    case BaselineVisibility.Protected:
                        yield return "protected";
                        break;
                    case BaselineVisibility.Internal:
                        yield return "internal";
                        break;
                    case BaselineVisibility.ProtectedInternal:
                        yield return "protected";
                        yield return "internal";
                        break;
                    case BaselineVisibility.Private:
                        yield return "private";
                        break;
                    default:
                        break;
                }

                if (Static)
                {
                    yield return "static";
                }

                if (ReadOnly)
                {
                    yield return "readonly";
                }

                if (Abstract)
                {
                    yield return "abstract";
                }

                if (Virtual && !Abstract && !Override)
                {
                    yield return "virtual";
                }

                if (Override)
                {
                    yield return "override";
                }

                if (New)
                {
                    yield return "new";
                }

                if (Sealed)
                {
                    yield return "sealed";
                }

                if (ReturnType != null)
                {
                    yield return ReturnType;
                }

                if (Kind != MemberBaselineKind.Field)
                {
                    yield return GetParametersComponent(Name);
                }
                else
                {
                    yield return Name;
                }
            }

            private string GetParametersComponent(string name)
            {
                var builder = new StringBuilder();

                builder.Append(name);
                builder.Append("(");
                for (int i = 0; i < Parameters.Count; i++)
                {
                    var parameter = Parameters[i];

                    builder.Append(parameter.Id);
                    if (i < Parameters.Count - 1)
                    {
                        builder.Append(", ");
                    }
                }

                builder.Append(")");
                return builder.ToString();
            }

            public MemberBaselineKind Kind { get; set; }
            public string Name { get; set; }
            public IList<ParameterBaseline> Parameters { get; set; } = new List<ParameterBaseline>();
            public string ReturnType { get; set; }
            public bool Sealed { get; set; }
            public bool Static { get; set; }
            public bool Virtual { get; set; }
            public bool Override { get; set; }
            public bool Abstract { get; set; }
            public bool New{ get; set; }
            public bool ReadOnly { get; set; }
            public BaselineVisibility Visibility { get; set; }

            public static string GetMemberNameFor(MethodBase member)
            {
                if (!member.IsGenericMethod)
                {
                    return member.Name;
                }

                var genericParameters = string.Join(", ", member.GetGenericArguments().Select(ga => TypeBaseline.GetTypeNameFor(ga.GetTypeInfo())));

                return $"{member.Name}<{genericParameters}>";
            }
        }

        public class ParameterBaseline : BaselineItem
        {
            public string Name { get; set; }
            public string Type { get; set; }
            public BaselineParameterDirection Direction { get; set; }
            public string DefaultValue { get; set; }
            public bool IsParams { get; set; }

            public override string Id
            {
                get
                {
                    return string.Join(" ", GetComponents());
                }
            }

            private IEnumerable<string> GetComponents()
            {
                switch (Direction)
                {
                    case BaselineParameterDirection.In:
                        break;
                    case BaselineParameterDirection.Out:
                        yield return "out";
                        break;
                    case BaselineParameterDirection.Ref:
                        yield return "ref";
                        break;
                    default:
                        break;
                }

                if (IsParams)
                {
                    yield return "params";
                }

                yield return Type;
                yield return Name;

                if (DefaultValue != null)
                {
                    yield return "=";
                    yield return DefaultValue;
                }
            }
        }

        public enum BaselineParameterDirection
        {
            In,
            Out,
            Ref
        }
    }
}